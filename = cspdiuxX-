STDARG(3)                   Linux Programmer's Manual                   STDARG(3)

NNAAMMEE
       stdarg, va_start, va_arg, va_end, va_copy - variable argument lists

SSYYNNOOPPSSIISS
       ##iinncclluuddee <<ssttddaarrgg..hh>>

       vvooiidd vvaa__ssttaarrtt((vvaa__lliisstt _a_p,, _l_a_s_t));;
       _t_y_p_e vvaa__aarrgg((vvaa__lliisstt _a_p,, _t_y_p_e));;
       vvooiidd vvaa__eenndd((vvaa__lliisstt _a_p));;
       vvooiidd vvaa__ccooppyy((vvaa__lliisstt _d_e_s_t,, vvaa__lliisstt _s_r_c));;

DDEESSCCRRIIPPTTIIOONN
       A  function  may  be  called with a varying number of arguments of varying
       types.  The include file _<_s_t_d_a_r_g_._h_> declares a type  _v_a___l_i_s_t  and  defines
       three  macros  for  stepping  through a list of arguments whose number and
       types are not known to the called function.

       The called function must declare an object of type _v_a___l_i_s_t which  is  used
       by the macros vvaa__ssttaarrtt(), vvaa__aarrgg(), and vvaa__eenndd().

   vvaa__ssttaarrtt(())
       The  vvaa__ssttaarrtt()  macro  initializes  _a_p for subsequent use by vvaa__aarrgg() and
       vvaa__eenndd(), and must be called first.

       The argument _l_a_s_t is the name of the last argument before the variable ar‐
       gument  list,  that  is,  the  last argument of which the calling function
       knows the type.

       Because the address of this argument may be used in the vvaa__ssttaarrtt()  macro,
       it  should  not be declared as a register variable, or as a function or an
       array type.

   vvaa__aarrgg(())
       The vvaa__aarrgg() macro expands to an expression that has the type and value of
       the next argument in the call.  The argument _a_p is the _v_a___l_i_s_t _a_p initial‐
       ized by vvaa__ssttaarrtt().  Each call to vvaa__aarrgg() modifies _a_p so  that  the  next
       call  returns  the next argument.  The argument _t_y_p_e is a type name speci‐
       fied so that the type of a pointer to an object  that  has  the  specified
       type can be obtained simply by adding a * to _t_y_p_e.

       The first use of the vvaa__aarrgg() macro after that of the vvaa__ssttaarrtt() macro re‐
       turns the argument after _l_a_s_t.  Successive invocations return  the  values
       of the remaining arguments.

       If  there  is no next argument, or if _t_y_p_e is not compatible with the type
       of the actual next argument (as promoted according to the default argument
       promotions), random errors will occur.

       If _a_p is passed to a function that uses vvaa__aarrgg((_a_p,,_t_y_p_e)),, then the value of
       _a_p is undefined after the return of that function.

   vvaa__eenndd(())
       Each invocation of vvaa__ssttaarrtt() must be matched by a  corresponding  invoca‐
       tion  of  vvaa__eenndd()  in  the  same function.  After the call vvaa__eenndd((_a_p)) the
       variable _a_p is undefined.  Multiple traversals of the list, each bracketed
       by  vvaa__ssttaarrtt()  and  vvaa__eenndd()  are possible.  vvaa__eenndd() may be a macro or a
       function.

   vvaa__ccooppyy(())
       The vvaa__ccooppyy() macro copies the (previously initialized) variable  argument
       list  _s_r_c  to _d_e_s_t.  The behavior is as if vvaa__ssttaarrtt() were applied to _d_e_s_t
       with the same _l_a_s_t argument, followed by the same number of vvaa__aarrgg() invo‐
       cations that was used to reach the current state of _s_r_c.

       An  obvious  implementation would have a _v_a___l_i_s_t be a pointer to the stack
       frame of the variadic function.  In such a setup (by far the most  common)
       there seems nothing against an assignment

           va_list aq = ap;

       Unfortunately,  there  are  also systems that make it an array of pointers
       (of length 1), and there one needs

           va_list aq;
           *aq = *ap;

       Finally, on systems where arguments are passed in  registers,  it  may  be
       necessary  for  vvaa__ssttaarrtt()  to allocate memory, store the arguments there,
       and also an indication of which argument is next,  so  that  vvaa__aarrgg()  can
       step  through the list.  Now vvaa__eenndd() can free the allocated memory again.
       To accommodate this situation, C99 adds a macro  vvaa__ccooppyy(),  so  that  the
       above assignment can be replaced by

           va_list aq;
           va_copy(aq, ap);
           ...
           va_end(aq);

       Each invocation of vvaa__ccooppyy() must be matched by a corresponding invocation
       of vvaa__eenndd() in the  same  function.   Some  systems  that  do  not  supply
       vvaa__ccooppyy()  have  ____vvaa__ccooppyy  instead,  since  that was the name used in the
       draft proposal.

AATTTTRRIIBBUUTTEESS
       For an explanation of the terms used in this section, see aattttrriibbuutteess(7).

       ┌──────────────────────┬───────────────┬─────────────────┐
       │IInntteerrffaaccee             │ AAttttrriibbuuttee     │ VVaalluuee           │
       ├──────────────────────┼───────────────┼─────────────────┤
       │vvaa__ssttaarrtt(), vvaa__eenndd(), │ Thread safety │ MT-Safe         │
       │vvaa__ccooppyy()             │               │                 │
       ├──────────────────────┼───────────────┼─────────────────┤
       │vvaa__aarrgg()              │ Thread safety │ MT-Safe race:ap │
       └──────────────────────┴───────────────┴─────────────────┘
CCOONNFFOORRMMIINNGG TTOO
       The vvaa__ssttaarrtt(), vvaa__aarrgg(), and vvaa__eenndd() macros conform to C89.  C99 defines
       the vvaa__ccooppyy() macro.

BBUUGGSS
       Unlike the historical vvaarraarrggss macros, the ssttddaarrgg macros do not permit pro‐
       grammers  to code a function with no fixed arguments.  This problem gener‐
       ates work mainly when converting vvaarraarrggss code to ssttddaarrgg code, but it  also
       creates difficulties for variadic functions that wish to pass all of their
       arguments on to a function that takes a  _v_a___l_i_s_t  argument,  such  as  vvff‐‐
       pprriinnttff(3).

EEXXAAMMPPLLEESS
       The  function  _f_o_o  takes a string of format characters and prints out the
       argument associated with each format character based on the type.

       #include <stdio.h>
       #include <stdarg.h>

       void
       foo(char *fmt, ...)   /* '...' is C syntax for a variadic function */

       {
           va_list ap;
           int d;
           char c;
           char *s;

           va_start(ap, fmt);
           while (*fmt)
               switch (*fmt++) {
               case 's':              /* string */
                   s = va_arg(ap, char *);
                   printf("string %s\n", s);
                   break;
               case 'd':              /* int */
                   d = va_arg(ap, int);
                   printf("int %d\n", d);
                   break;
               case 'c':              /* char */
                   /* need a cast here since va_arg only
                      takes fully promoted types */
                   c = (char) va_arg(ap, int);
                   printf("char %c\n", c);
                   break;
               }
           va_end(ap);
       }

SSEEEE AALLSSOO
       vvpprriinnttff(3), vvssccaannff(3), vvssyysslloogg(3)

CCOOLLOOPPHHOONN
       This page is part of release 5.10 of the Linux _m_a_n_-_p_a_g_e_s project.   A  de‐
       scription of the project, information about reporting bugs, and the latest
       version      of      this      page,      can      be       found       at
       https://www.kernel.org/doc/man-pages/.

                                    2020-11-01                          STDARG(3)
